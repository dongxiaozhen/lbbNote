git
git config --global user.name "xxx"
git config --global user.email xxxxx
git config --list
git config --global --list
git config --global https.proxy='xxx'
git config --global --unset https.proxy

github
	github.com
	1.开源软件点击fork就会在自己的账户下复制那个项目
	2.clone地址，然后在本地执行git clone xxxxx(网址)

添加文件.gitignore到根目录，里面填写要忽略的文件名 (项目全局共享)
添加文件名到.git/info/exclude文件中      			(个人局部设置)
git config --global core.excludesfile /home/lbb/.gitignore (个人全局)
git status --ignored -s (显示忽略跟踪的文件名)


git pull == git fetch + git merger
git pull --rebase  = git fetch + git rebase 

git remote -v 远程的git地址

git rev-parse --git-dir         显示.git目录所在的位置
git rev-parse --show-toplevel    显示工作区根目录
git rev-parse --show-prefix      显示相对于工作区根目录的相对目录

git stash save "mesage" == git stash ,但是可以写说明
git stash list				显示所有stash
git stash drop xxxx			清楚xxxx stash
git stash drop clear        清楚所有的stash

git checkout 改变的事refs/HEAD文件里分支名称
	git checkout -- filename 将取消work区的修改
	git checkout branch 切换分支
	git checkout -b branch 创建并切换分支
	git checkout  -b develop origin/master        // 创建并切换封装develop, 指向origin/master分支顶点端。

git reset 改变的是refs/head/branchName文件里的ID
	git reset HEAD filename 将stage中的提价退回到work区，(只是从stage到work,数据还在)
	git reset --soft commitID 将原先HEAD 到 commitID 之间的提交转到了stage中，refs/head/branchName指向commitID
	git reset  commitID 将原先HEAD 到 commitID 之间的提交转到了work中，refs/head/brancNname指向commitID
	git reset  commitID 将原先HEAD 到 commitID 之间的提交在work，stage中删除H，refs/head/branchName指向commitID
	
git clean -f     删除未跟踪文件

git cherry-pick xxxx 用于把另一个本地分支的commit修改应用到当前分支。     xxxx(commitID)

git push origin master:refs/for/mybranch (在local repository中找到名字为master的branch，用他去更新remote repository下面名字为mybranch的branch)

git fsck --lost-found  丢失分支和stash后，用来恢复

重置（reset）一般用于重置暂存区(除非使用--hard参数，否则不重置工作区)，而检出（checkout）命令主要是覆盖工作区（如果<commt>不省略，也会替换暂存区中相应的文件）。
	   git push origin master:refs/for/master

（1丢弃B）
----A---------B---------C----D---E-----F
  start   discard     begin           end

	 git rebase --onto A B F((B,F]左开右闭)
	 git rebase -i A  (然后去掉B的commit)


（2 BC合并）
----A---------B---------C----D---E-----F
  start       begin    end

      git rebase -i A  (然后改C为squad)

git rebase -i 
	删除一行commit 就相当于将该次提交删除
	reword 可以修改此次commit message
	squad 此行提交和前一次合并
	edit 此提交可以修改(添加，删除，修改内容到此提交)

里程碑tag
  git tag -m "xxx" name <commitID>创建
  git tag -d name   删除
  git discrible
  git push origin tagName  创建远程tag
  git push origin :tagName 删除远程的tag

 分支管理branch
	git branch name <start-point> 创建分支           （branch不能切换分支，需要checkout）
	git branch -d name 检查name分支是否已经合并到其他分支，否则拒绝删除
	git branch -D name 强制删除
	git branch -m/-M oldname newname  重命名分支（拒绝/强制）

git rebase orign/master 和git merger的却别   （在develop分支放到orign/master分支后面）
（原始结构）
	c1--------c2---------c3--------c4（origin)
	           -
			     -------c5-------c6(develop)

(rebase后的结构)
	c1--------c2---------c3--------c4(origin)
	                                 -
			                          -------c5-------c6(develop)
(merger后的结构)
	c1--------c2---------c3--------c4(origin)
	            --                     --
			      -------c5-------c6     -
				                    - ----c7(develop)
补丁
   *git format-patch -s HEAD~3..HEAD或者SHA1ID   某次提交以后的所有patch
	git format-patch -M master         // 当前分支所有超前master的提交
	git apply --stat newpatch.patch     // 先检查patch文件：#
    git apply --check  newpatch.patch    检查能否应用成功：#
   *git am xxx

repo
	repo init -u
	repo sync 克隆或同步本地文件
	repo start 实际上是对git checkout -b 命令的封装

显示指定文件相关的每一次diff
    git log -p [file]
显示指定文件是什么人在什么时间修改过
    git blame [file]
git whatchanged  filename  显示某个文件的每个版本提交信息：提交日期，提交人员，版本号，提交备注
gitk -- filename   gitk显示

git diff 			work和stage的比较
git diff --cached 	stage 与HEAD比较
git diff HEAD 		work,stage中的内容和 HEAD比较


