可重入和不可重入函数   
   主要用于多任务环境中，一个可重入的函数简单来说就是可以被中断的函数，也就是说，可以在这个函数执行的任何时刻中断它，
转入OS调度下去执行另外一段代码,而返回控制时不会出现什么错误；而不可重入的函数由于使用了一些系统资源，
比如全局变量区，中断向量表等，所以它如果被中断的话，可能会出现问题，这类函数是不能运行在多任务环境下的。
   也可以这样理解，重入即表示重复进入，首先它意味着这个函数可以被中断，其次意味着它除了使用自己栈上的变量以外不依赖于任何环境（包括static），
这样的函数就是purecode（纯代码）可重入，可以允许有该函数的多个副本在运行，由于它们使用的是分离的栈，所以不会互相干扰。如果确实需要访问全局变量（包括static），
一定要注意实施互斥手段。可重入函数在并行运行环境中非常重要，但是一般要为访问全局变量付出一些性能代价。
   编写可重入函数时，若使用全局变量，则应通过关中断、信号量（即P、V操作）等手段对其加以保护。
   说明：若对所使用的全局变量不加以保护，则此函数就不具有可重入性，即当多个进程调用此函数时，很有可能使有关全局变量变为不可知状态
   
   
observer 模式
	观察者模式又叫做发布-订阅（Publish/Subscribe）模式、模型-视图（Model/View）模式、源-监听器（Source/Listener）模式或从属者（Dependents）模式。

    观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知所有观察者对象，使它们能够自动更新自己。

    一个软件系统常常要求在某一个对象的状态发生变化的时候，某些其它的对象做出相应的改变。做到这一点的设计方案有很多，但是为了使系统能够易于复用，应该选择
低耦合度的设计方案。减少对象之间的耦合有利于系统的复用，但是同时设计师需要使这些低耦合度的对象之间能够维持行动的协调一致，保证高度的协作（Collaboration）。
观察者模式是满足这一要求的各种设计方案中最重要的一种。

线程安全的构造函数
	对象构造要做到线程安全，唯一的要求就是在构造函数期间不要泄露this指针，即
	1：不要在构造函数中注册任何调用。
	2：也不要在构造函数中把this传给跨线程的对象；
	3：即便在构造函数的最后一行也不行
	
组合和关联    x的生命期是否有owner控制，


两种I/O多路复用模式：Reactor和Proactor

	一般地,I/O多路复用机制都依赖于一个事件多路分离器(Event Demultiplexer)。分离器对象可将来自事件源的I/O事件分离出来，并分发到对应的read/write事件处理器
(Event Handler)。开发人员预先注册需要处理的事件及其事件处理器（或回调函数）；事件分离器负责将请求事件传递给事件处理器。两个与事件分离器有关的模式是
Reactor和Proactor。Reactor模式采用同步IO，而Proactor采用异步IO。

必须用单线程额场合
	程序有可能fork(2)
	限制程序的CPU占用率
	
强行终止线程的话（无论是他杀还是自杀，）它没有机会清理资源。


POD(plain old data)类型
	所有标量类型(基本类型和指针类型)、POD结构类型、POD联合类型、以及这几种类型的数组、const/volatile修饰的版本都是POD类型。

C++11将POD划分为两个基本概念的集合(只有满足这两个基本概念才能成为是POD类型):
	1.平凡的(trivial)
		1.1拥有平凡的默认构造函数(trivial constructor)和析构函数(trivial destructor).(trivial constructor就是说构造函数什么都不干,通常情况下, 不定义类
		的构造函数, 编译器就会自动生成一个trivial constructor, 而一旦定义了构造函数, 即使构造函数中不包含任何参数, 函数体中也没有任何代码, 那么该构造函数都不再是trivial的(non-trivial),)
		1.2拥有平凡的复制构造函数(trivial copy constructor)和移动构造函数(trivial move constructor),
		1.3拥有平凡的复制赋值运算符(trivial assignment operator)和移动赋值运算符
		1.4不能包含虚拟函数和虚拟基类.
		
	2.标准布局的(standard layout)
		2.1所有非静态成员都有相同的访问权限(public, private, protected).
		2.2 2在class或者struct继承时, 满足以下两种情况之一:
				·派生类中有非静态成员, 且只有一个仅包含静态成员的基类.
				·基类有非静态成员, 而派生类没有非静态成员.
		2.3类中第一个非静态成员的类型与其基类不同
		2.4没有虚拟函数和虚基类 
		2.5)所有非静态数据成员均符合标准 布局类型 , 其基类也符合标准布局. 这是一个递归定义
		
对象范式的两个基本观念：
    程序是由对象组成的；
    对象之间互相发送消息，协作完成任务；
