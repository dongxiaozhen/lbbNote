+--------------------+---------+----------------------------------------------------------------------------+--------------+------+------------+
| Engine             | Support | Comment                                                                    | Transactions | XA   | Savepoints |
+--------------------+---------+----------------------------------------------------------------------------+--------------+------+------------+
| InnoDB             | DEFAULT | Percona-XtraDB, Supports transactions, row-level locking, and foreign keys | YES          | YES  | YES        |
+--------------------+---------+----------------------------------------------------------------------------+--------------+------+------------+


主键 树
索引 树

隔离级别
 1 read uncommitted 可以读取未提交的数据
 1 rc  read committed 不会出现脏读
 2 rr  reapeated read ,同一事务前后两次读取的数据时一致的。可能出现幻读
 3 serializable, 所有的读都要上锁

https://blog.csdn.net/Me_xuan/article/details/123364357

幻读指的是多了一个或者少了一个，就像幻影一样，是和一个范围有关的，幻读的必要条件是两个，第一是有Insert/delete操作，第二个是你做了范围查询；
repeated read实现：在rc的基础上增加了GAP锁,保证不会再增加新的数据.GAP的出现条件时,where 语句后面的Key 不是主键也不是唯一索引,因为这两种情况下不会增加新数据

非serializable 读取上S(共享)锁，更删增设置X(排他)锁
表锁和行锁
 在表没有索引的条件下，使用表锁,否则使用行锁

不可重复读和幻读的区别
很多人容易搞混不可重复读和幻读，确实这两者有些相似。但不可重复读重点在于update和delete，而幻读的重点在于insert。
如果使用锁机制来实现这两种隔离级别，在可重复读中，该sql第一次读取到数据后，就将这些数据加锁，其它事务无法修改这些数据，就可以实现可重复 读了。但这种方法却无法锁住insert的数据，所以当事务A先前读取了数据，或者修改了全部数据，事务B还是可以insert数据提交，这时事务A就会 发现莫名其妙多了一条之前没有的数据，这就是幻读，不能通过行锁来避免。需要Serializable隔离级别 ，读用读锁，写用写锁，读锁和写锁互斥，这么做可以有效的避免幻读、不可重复读、脏读等问题，但会极大的降低数据库的并发能力。
所以说不可重复读和幻读最大的区别，就在于如何通过锁机制来解决他们产生的问题。
上文说的，是使用悲观锁机制来处理这两种问题，但是MySQL、ORACLE、PostgreSQL等成熟的数据库，出于性能考虑，都是使用了以乐观锁为理论基础的MVCC（多版本并发控制）来避免这两种问题。


表空间
   所有的数据都属于表空间
   如果设置了 innodb_file_per_table,则每张表的收据单独存放一个表空间
段
   数据段(b+树的叶节点),索引段，回滚段
区
  64个连续的页组成的,即1M。
页
  每个也16K
  数据页，undo页，系统页，事务数据页，插入数据位图页.
行
  compact: 变长字段长度列表 | NULL标志位 | 记录头信息 | 列数据 | ...| 
  redundant: 字段长度偏移列表 | 记录头信息 | 列数据| ... |
  Fixed,Dynamic,Barracuda
  行溢出：将一条记录的某些数据存储在真正的数据页面之外. 所有可变长度的列长度不超多65532。

  
  // show table status like 'aa';

意向锁是表级别的锁
在INFORMATION_SCHEMA架构下添加了INNODB_TRX、INNODB_LOCKS、INNODB_LOCK_WAITS
在InnoDB存储引擎中，事务日志通过重做（redo）日志文件和InnoDB存储引擎的日志缓冲（InnoDB Log Buffer）来实现
就是在写数据前，需要先写日志。这种方式称为预写日志方式（Write-Ahead Logging，WAL）。
redo不同的是，redo存放在重做日志文件中，undo存放在数据库内部的一个特殊段（segment）中，这称为undo段（undo segment），undo段位于共享表空间内。



快照读：读取快照中的数据，不需要进行加锁。看到快照这两个字，各位肯定马上就想到 MVCC 了，是这样，MVCC 作用于读取已提交和可重复读（默认）这两个隔离级别，这俩隔离级别下的普通 select 操作就是快照读
当前读：读取的是最新版本的数据, 并且对读取的记录加锁, 阻塞其他事务同时改动相同记录，避免出现安全问题。


