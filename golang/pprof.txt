https://github.com/hyper0x/go_command_tutorial/blob/master/0.12.md
https://blog.golang.org/profiling-go-programs
https://www.yuque.com/ksco/uiondt/khpvy5

go tool pprof /path/to/your/profile
go tool pprof -http=:8080 /var/folders/by/3gf34_z95zg05cyj744_vhx40000gn/T/profile239941020/cpu.pprof
curl -o trace.out http://127.0.0.1:8080/debug/pprof/trace?seconds=5

go tool pprof binaryFile pprofFile

在栈顶的次数 (正在执行该函数)
在栈中出现的次数 (该函数在直接或者间接的执行其他函数)

箭头是调用关系，数字代表：A正在调用B的次数

CPU 性能分析
    CPU 性能分析是最常见的性能分析，也是最明显的。
    启用 CPU 性能分析后，运行时将每 10 毫秒中断一次，并记录当前正在运行的 goroutine 的堆栈跟踪。
    分析完成后，我们可以对其进行分析，以确定最需要分析的代码模块。
    函数在性能分析中出现的次数越多，代码模块占总运行时百分比的时间就越多

内存性能分析
    内存分析记录在堆分配时记录堆栈跟踪。
    假定堆栈分配是空闲的，并且在内存分析文件中未跟踪。
    内存分析，和 CPU 分析一样也是基于样本的，每 1000 个分配中的内存分析样本为1。这个比率可以改变。
    因为内存分析是基于样本的，因为它跟踪不使用的分配，所以使用内存分析来确定应用程序的总内存使用是困难的。
    个人观点：我不认为内存分析有助于发现内存泄漏。有更好的方法来确定你的应用程序使用了多少内存。稍后我们将在 PPT 中讨论这些问题。

阻塞分析
	阻塞分析在 Go 中是非常独特的。
	阻塞分析和 CPU 分析很像，但它记录 goroutine 花在等待共享资源上的时间。
	这对于确定应用程序中的并发瓶颈可能是有用的。
	阻塞分析可以显示大量 goroutine 何时可以取得结果，阻塞。阻塞包括：
	在未缓冲信道上发送或接收。
	发送数据到一个满了的信道，从一个空的信道接收数据。
	试图给另一个 goroutine 锁住的 sync.mutex 的上锁。
	阻塞分析是一种非常专业的工具，在你确信已经消除了所有 CPU 和内存使用瓶颈之前，不应该使用它。

互斥性能分析
	互斥锁分析与阻塞分析类似，但只专门针对导致互斥锁争用导致延迟的操作上。
	我对这种类型的分析没有很多经验，但是我搞了个 PPT 来演示它。我们将很快看到该示例。
    

一次只有一个分析
	性能分析不是免费的。
	分析对程序性能有一定的影响，特别是如果增加分析的采样率。
	大多数工具不会阻止你同时启用多个分析。
	一次不要启用多次分析。 
	如果你同时启用多个分析，他们将观察自己的相互作用并抛出你的结果。
