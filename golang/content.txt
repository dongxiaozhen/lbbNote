book 
	golang-china/gopl-zh/
	https://tiancaiamao.gitbooks.io/go-internals/content/zh/
	https://golang.org/doc/effective_go.html

gdb 调试golang   
	gdb xxxx 然后source /usr/local/go/src/runtime/runtime-gdb.py  就可以使用 info goroutine 
	dlv 调试

slices, maps, and functions: these types cannot be compared using ==, and may not be used as map keys.
	slice,map里面存放数据的数组可能会调整大小，从而引起前后数据的不一致。

string 
	type = struct string { uint8 *str; int len; }

time
	Timer定时完需要重置
	ticker 就是一直循环定时
	time有个goroutine，采用堆结构处理时间，当时间到期后会调用sendTime()无阻塞(select)的填充Timer里的chan。

select 里面定时不要在里边写time.After(d)，原因就是select每次执行都会重新执行case语句,并重新注册到select中。
switch不会自动从一个case子句跌落到下一个case子句。但是case可以使用逗号分隔的列表。

变量shadow问题  外部定义的变量，在其他范围{}内使用:=来赋值(情况多出现在和err同时赋值时),回出现变量隐藏的问题  go tool vet -shadow xx.go 可以发现这个问题

channel src/runtime/chan.go   make(chan int) 返回的是一个指针 *hchan
	只能在多个goroutine中使用
	向关闭的channel 中发送数据会引发panic,在一个nil的channel上发送，接受数据会被永远阻塞,一个channel关闭多次会panic,
	监听关闭的channel，依然可以接受到之前成功发送的数据，如果已经没有数据会产生一个零值的数据。
	v,ok:=<-ch ok==true:v数据有效，ok==false:chan关闭，可以直接使用range遍历数据
	无缓存chan,接收端准备好后发布端才会继续执行，有缓存chan接收端可以放下就继续执行
	channel 类型可以比较,当且仅当两chan引用的时同一个对象。

[]type          slice = struct []type{ type *array; int len; int cap; }

range语句中的生成的数据是真实数据的拷贝，[],map,channel
被defer的调用(函数)会在包含的函数的结尾执行，而不是代码块哦末尾(if,for)
map 
	类型创建返回的是指针 type = struct hash<keyType,valueType> {
	    int count;
	    uint8 flags;
	    uint8 B;
	    uint32 hash0;
	    struct bucket<keyType,valueType> *buckets;
	    struct bucket<keyType,valueType> *oldbuckets;
	    uintptr nevacuate;
	    [2]*[]*runtime.bmap *overflow;
	} *
	
	map 取不存在的key的value,返回零直

context 包实现了对多个派生go的管理，每个需要监听ctx.Done()退出，正常完成后调用CancelFunc

go net/http  
	客户端 tcp请求完成后 response body指向con(需要自己调用read,close方法)
		每个客户端里缓存之前的所有远程连接，每个con有两个goroutine:readloop,writeloop
	服务器 tcp listen ,连接上后开启一个goroutine, 读取解析协议。读写用到了limitread , buffreader,buffwrite 
	

break
	break只能中断当前最近的一个for,swtich,select;如果要跳出外面的for,switch,select需要使用标签。标签要放在for,switch,select的前面。
goto
	跳到goto指向的标签处

闭包：
	闭包函数传参和不传参，直接调用外面的变量，参数的拷贝。
	struct {F func, Arg args}

interface 可以比较，只有type,value都相同时才相等 
	src/runtime/iface.go 带方法的借口 struct runtime.iface { runtime.itab *tab; void *data; }, 空借口type eface struct { _type *_type data  unsafe.Pointer }  
	reflect.Type == runtime._type

	type itab struct {
   		 inter  *interfacetype  // 接口信息
   		 _type  *_type          // value 信息(静态类型)
   		 link   *itab
   		 bad    int32
   		 unused int32
   		 fun    [1]uintptr // variable sized
	}
	var1,ok:=i1.(type) 接口i1的type是不是type1, 返回的是类型type1的变量
	i3:=i1.(i2)   接口i1的value有没有实现i2接口,返回的结果是i2类型的接口

	reflect
		逆操作：reflect.ValueOf(a).Interface()
		reflect.Type(a).Kind() 返回structkind
		reflect.ValueOf(a).String() 返回 struct名字

	switch rr:=a.(type)   (type)只能在switch中出现，rr是变量，可以操作,相当于遍历a.(type)

method(方法)只是添加对象为func(函数)的第一个参数
