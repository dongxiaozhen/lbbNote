:Author: libinbin
:Email: libinbin@lmv
:Date: 2018-08-27 20:37

------------------------------------------------------
|单节点数量 |   1万  |  100万  |   100亿  |   1000亿 |
|-----------|--------|---------|----------|----------|
|   2       |   14   |   20    |   34     |    37    |
|-----------|--------|---------|----------|----------|
|   6       |   6    |    8    |   13     |    15    |
|-----------|--------|---------|----------|----------|
|   10      |   4    |    6    |   10     |    11    |
|-----------|--------|---------|----------|----------|
|   20      |   3    |    5    |    7     |     9    |
|-----------|--------|---------|----------|----------|
计算方法：s(n) = a1(1-q^n)/1-q

操作展示
   https://www.cs.usfca.edu/~galles/visualization/Algorithms.html


IntervalTree
   线段树

 

btree
  最大数量 maxItems = 2*degree - 1
  最小数量 minItems = degree -1 
  insert   (只能在叶子节点插入数据,分裂产生父节点)
     1 查找，找到就赋值。
     2 检查该节点有没有children,没有就直接插入
     3 检查children节点的item数量是否大于等于maxItems,是则应该分裂，
       3.1 一分为二 second1,item,second2，中间item提升到父节点。second2加入父节点
     4 递归
    
   delete 
     1 叶子节点找到直接删除
     2 非叶子节点找到后,判断子节点的item数量是否小于minItems,是则
        2.1 如果该children 有左兄弟且其item数量大于minItems,
           2.1.1 将父节点item 插入到右children的0号位置
           2.1.2 删除左兄弟的最大值,赋值给父节点,其children 赋值到右兄弟的0children
        2.2 如果该children 有右兄弟且其item数量大于minItems,
           2.2.1 将父节点item 插入到左children的0号位置
           2.2.2 删除右兄弟的最小值,赋值给父节点,其children 赋值到左兄弟的最后一个children
        2.3 和右兄弟,父节点合并,删除父节点的右children
     3 递归



AVL树 平衡树   https://mp.weixin.qq.com/s/VX2TdgIlXDpUZ4AiU5pDeQ
   第一个方向标示节点的哪个方向的节点数大了，第二个方向表示最后一个节点的位置
   1、左-左型：做右旋。
   2、右-右型：做左旋转。
   3、左-右型：先做左旋，后做右旋。
   4、右-左型：先做右旋，再做左旋。

2-3tree
   特点：能够自我保持平衡,且所有节点的深度都一样
   红黑树的关系： 左节点是红色节点相当于2-3tree的3节点


红黑树的特性:
（1）每个节点或者是黑色，或者是红色。
（2）根节点是黑色。
（3）每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！]
（4）如果一个节点是红色的，则它的子节点必须是黑色的。(不能同时出现两个红色的节点)
（5）从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。
  
   左右节点深度相差最多两倍，深度最少的分支都是黑色节点，深度最多的分支时红黑相间的，例如 黑黑黑黑， 红黑红黑红黑红黑红
   添加需要调整的情况
     ● 插入修复情况1：如果当前结点z的父结点是红色且祖父结点的另一个子结点（叔叔结点）是红色
     ● 插入修复情况2：当前节点z的父节点是红色,叔叔节点是黑色，当前节点是其父节点的右子
     ● 插入修复情况3：当前节点z的父节点是红色,叔叔节点是黑色，当前节点是其父节点的左子

对x进行左旋，意味着，将“x的右孩子”设为“x的父亲节点”；即，将 x变成了一个左节点(x成了为z的左孩子)！。 因此，左旋中的“左”，意味着“被旋转的节点将变成一个左节点”。
对x进行右旋，意味着，将“x的左孩子”设为“x的父亲节点”；即，将 x变成了一个右节点(x成了为y的右孩子)！ 因此，右旋中的“右”，意味着“被旋转的节点将变成一个右节点”

红黑树添加
  f-b            : 直接设置
  f-r,u-r        : f-b,u-b,ff-r 
  f-r,u-b,x==r(f): f左旋
  f-r,u-b        : ff右旋 思想是：将红色的节点移到根节点；然后，将根节点设为黑色

红黑树删除
  删除操作首先要确定待删除节点有几个孩子，如果有两个孩子，不能直接删除该节点。而是要先找到该节点的前驱（该节点左子树中最大的节点）或者后继（该节点右子树中最小的节点），
  然后将前驱或者后继的值复制到要删除的节点中，最后再将前驱或后继删除。由于前驱和后继至多只有一个孩子节点，这样我们就把原来要删除的节点有两个孩子的问题转化为只有一个孩子节点的问题，d为要删除的节点,dl肯定是nil，后继为nil
  d-r: 直接删除
  d-b,dr-r : 直接使用DR去补缺口并且改变颜色即可
  d-b,dr-nil,u-r: 以u为支点左旋，s,u,f变色
  d-b,dr-nil,u-b,ul/ur -r :  
  d-b,dr-nil,u-b,ul/ur==nil,p-r:
  d-b,dr-nil,u-b,ul/ur==nil,p-b:





B+树中间节点没有卫星数据，只存索引数据，所以同样大小的磁盘页可以容纳更多的节点元素，这就意味着，数据量相同的情况下B+树比B树更加的”矮胖“，相应会减小IO次数。其次，B+树的查询必须最终查找到叶子节点，而B树只要找到匹配元素即可，无论匹配元素处于中间节点还是叶子节点。
综合起来，B+树比B树的优势有三个：
1、单一节点存储更多的元素，使得查询的IO次数减少；
2、所有查询都要查找到叶子节点，查询性能稳定；
3、所有叶子节点形成有序链表，便于范围查询。
https://www.cnblogs.com/nullzx/p/8729425.html
