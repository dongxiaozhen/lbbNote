静态函数库（对应.a文件）、共享函数库（对应.so文件，类似于Windows的dll文件）、动态加载函数库（对应.o文件，相当于Windows里的.obj文件）

静态函数库
	特点：实际上是简单的普通目标文件的集合，在程序执行前就加入到目标程序中。
优点：可以用以前某些程序兼容；描述简单；允许程序员把程序link起来而不用重新编译代码，节省了重新编译代码的时间（该优势目前已不明显）；开发者可以对源代码保密；理论上使用ELF格式的静态库函数生成的代码可以比使用共享或动态函数库的程序运行速度快（大概1%-5%）
生成：使用ar程序（archiver的缩写）。ar rcs my_lib.a f1.o f2.o是把目标代码f1.o和f2.o加入到my_lib.a这个函数库文件中（如果my_lib.a不存在则创建）
使用：用gcc生成可执行代码时，使用-l参数指定要加入的库函数。也可以用ld命令的-l和-L参数。

共享函数库
    共享函数库在可执行程序启动的时候加载，所有程序重新运行时都可自动加载共享函数库中的函数。.so文件感觉很复杂，光是命名规则就已经看得我很晕了~整理一下，共享库需要：soname、real name，另外编译的时候名字也有说法。依次解释下：
soname：必须的格式：lib+函数库名+.so+版本号信息（但是记住，非常底层的C库函数都不是以lib开头命名的）。例子：/usr/lib/libreadline.so.3
real name：顾名思义是真正的名字啦，有主版本号和发行版本号。但是没找到实例……
编译器编译的时候需要的函数库的名字就是不包含版本号信息的soname，例如上面的例子把最后的.3去掉就可以了。
位置：共享函数库文件必须放在特定目录，对于开放源码来说，GNU标准建议所有的函数库文件都放在/usr/local/lib目录下，而且建议命令、可执行程序都放在/usr/local/bin目录下。不过这个只是习惯啦，可以改变，具体的位置信息可以看/etc/ld.so.conf里面的配置信息。当然，也可以修改这个文件，加入自己的一些特殊的路径要求。

动态库创建
    gcc test_a.c test_b.c test_c.c -fPIC -shared -o libtest.so 
		-shared 该选项指定生成动态连接库
		-fPIC：表示编译为位置独立的代码，不用此选项的话编译后的代码是位置相关的所以动态载入时是通过代码拷贝的方式来满足不同进程的需要，而不能达到真正代码段共享的目的。
动态库使用
	 gcc test.c -L. -ltest -o test
		-L.：表示要连接的库在当前目录中
		-ltest：编译器查找动态连接库时有隐含的命名规则，即在给出的名字前面加上lib，后面加上.so来确定库的名称

查看：
	可以通过运行ldd来看某个程序使用的共享函数库。例如ldd /bin/ls。
	
拷贝共享库文件到指定的标准的目录，然后运行ldconfig。如果没有权限这样做，那么就只好通过修改环境变量来实现这些函数库的使用了。方法不再说了，很复杂。

关于覆盖：如果想用自己的函数覆盖某个库中的一些函数，同时保留该库中其他的函数的话，可以在/etc/ld.so.preload中加入要替换的库（.o结尾的文件），这些preloading的库函数将有优先加载的权利。
关于更新：每次新增加动态加载的函数库、删除某个函数库或者修改某个函数库的路径时，都要重新运行ldconfig来更新/etc/ld.so.cache


undefined reference 和undefined symbol 错误的原因是：
(1) 没有指定对应的库（.o/.a/.so）。 使用了库中定义的实体，但没有指定库（-lXXX）或者没有指定库路径（-LYYY），会导致该错误。
(2) 连接库参数的顺序不对。在默认情况下,对于-l 使用库的要求是越是基础的库越要写在后面,无论是静态还动态。
