以下划线开头的标识符是有特殊意义的。以单下划线开头 _foo 的代表不能直接访问的类属性，需通过类提供的接口进行访问，不能用 from xxx import * 而导入；
以双下划线开头的 __foo 代表类的私有成员；以双下划线开头和结尾的 __foo__ 代表 Python 里特殊方法专用的标识，如 __init__() 代表类的构造函数。


Python 可以使用引号( ' )、双引号( " )、三引号( ''' 或 """ ) 来表示字符串，引号的开始与结束必须的相同类型的。
其中三引号可以由多行组成，编写多行文本的快捷语法，常用于文档字符串，在文件的特定地点，被当做注释。
python 中多行注释使用三个单引号(''')或三个双引号(""")。

像if、while、def和class这样的复合语句，首行以关键字开始，以冒号( : )结束，该行之后的一行或多行代码构成代码组。
print 默认输出是换行的，如果要实现不换行需要在变量末尾加上逗号：

每个变量在使用前都必须赋值，变量赋值以后该变量才会被创建。

Numbers（数字） 
    int（有符号整型）
    long（长整型[也可以代表八进制和十六进制]） 长整型也可以使用小写 l，但是还是建议您使用大写 L，避免与数字 1 混淆。Python使用 L 来显示长整型。
    float（浮点型）
    complex（复数）
String（字符串）
    Unicode 字符串 引号前小写的"u"表示这里创建的是一个 Unicode 字符串
List（列表）
Tuple（元组） 元组用"()"标识,只读列表
Dictionary（字典）字典用"{ }"标识
    键必须不可变，所以可以用数字，字符串或元组充当，所以用列表就不行，如下实例：
    

转换函数
    int(x [,base])将x转换为一个整数
    long(x [,base] )将x转换为一个长整数
    float(x)将x转换到一个浮点数
    complex(real [,imag])创建一个复数
    str(x)将对象 x 转换为字符串
    repr(x)将对象 x 转换为表达式字符串
    eval(str)用来计算在字符串中的有效Python表达式,并返回一个对象
    tuple(s)将序列 s 转换为一个元组
    list(s)将序列 s 转换为一个列表
    set(s)转换为可变集合
    dict(d)创建一个字典。d 必须是一个序列 (key,value)元组。
    frozenset(s)转换为不可变集合
    chr(x)将一个整数转换为一个字符
    unichr(x)将一个整数转换为Unicode字符
    ord(x)将一个字符转换为它的整数值
    hex(x)将一个整数转换为一个十六进制字符串
    oct(x)将一个整数转换为一个八进制字符串
    
运算
    //	取整除 - 返回商的整数部分
    
    比较运算 != 不等于
             <> 不等于
    
    辑运算符 and or not
    身份运算符 is    两个标识符是不是引用自一个对象
               is not
               
    if elif else
    while … else
    for … else 
    try....except...else
    try-finally 
    raise语句自己触发异常
    

函数 len() 返回列表的长度，即元素的个数。 range返回一个序列的数。
    
    
python 使用 lambda 来创建匿名函数。
lambda只是一个表达式，函数体比def简单很多。
lambda的主体是一个表达式，而不是一个代码块。仅仅能在lambda表达式中封装有限的逻辑进去。
lambda函数拥有自己的命名空间，且不能访问自有参数列表之外或全局命名空间里的参数。
虽然lambda函数看起来只能写一行，却不等同于C或C++的内联函数，后者的目的是调用小函数时不占用栈内存从而增加运行效率。

包就是文件夹，但该文件夹下必须存在 __init__.py 文件, 该文件的内容可以为空。__int__.py用于标识当前文件夹是一个包。
    
    
类
第一种方法__init__()方法是一种特殊的方法，被称为类的构造函数或初始化方法，当创建了这个类的实例时就会调用该方法
析构函数 __del__ ，__del__在对象销毁的时候被调用，当对象不再被使用时，__del__方法运行：
self 代表类的实例，self 在定义类的方法时是必须有的，虽然在调用时不必传入相应的参数。
__str__( self ) 用于将值转化为适于人阅读的形式， 简单的调用方法 : str(obj)
_cmp__ ( self, x )对象比较，简单的调用方法 : cmp(obj, x)
__add__(self,other):运算符重载


__dict__ : 类的属性（包含一个字典，由类的数据属性组成）
__doc__ :类的文档字符串
__name__: 类名
__module__: 类定义所在的模块（类的全名是'__main__.className'，如果类位于一个导入模块mymod中，那么className.__module__ 等于 mymod）
__bases__ : 类的所有父类构成元素（包含了一个由所有父类组成的元组）


在python中继承中的一些特点：
1：在继承中基类的构造（__init__()方法）不会被自动调用，它需要在其派生类的构造中亲自专门调用。
2：在调用基类的方法时，需要加上基类的类名前缀，且需要带上self参数变量。区别在于类中调用普通函数时并不需要带上self参数
3：Python总是首先查找对应类型的方法，如果它不能在派生类中找到对应的方法，它才开始到基类中逐个查找。（先在本类中查找调用的方法，找不到才去基类中找）。


__private_attrs：两个下划线开头，声明该属性为私有

yield 迭代器中使用，类似return

列表生成器 [x * x for x in range(10)]
生成器 
    (x * x for x in range(10))  // 使用next(xxx) 或者 for x in xxx
    func 里调用yield

凡是可作用于for循环的对象都是Iterable类型；
凡是可作用于next()函数的对象都是Iterator类型，它们表示一个惰性计算的序列；

map()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回
reduce把一个函数作用在一个序列[x1, x2, x3, ...]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算
filter()也接收一个函数和一个序列,把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素

匿名函数 lambda x: x * x

装饰器 借助Python的@语法，把decorator置于函数的定义处
@log
def now():
    print('2015-3-25')

now = log(now)
import functools是导入functools模块。模块的概念稍候讲解。现在，只需记住在定义wrapper()的前面加上@functools.wraps(func)即可。


模块
内置模块  https://docs.python.org/zh-cn/3/library/functions.html
一个.py文件就称之为一个模块（Module）
目录来组织模块的方法，称为包（Package）
每一个包目录下面都会有一个__init__.py的文件，这个文件是必须存在的，否则，Python就把这个目录当成普通目录，而不是一个包。__init__.py可以是空文件，也可以有Python代码，因为__init__.py本身就是一个模块，而它的模块名就是mycompany。
作用域
    正常的函数和变量名是公开的（public），可以被直接引用
    类似__xxx__这样的变量是特殊变量，可以被直接引用，但是有特殊用途
    类似_xxx和__xxx这样的函数或变量就是非公开的（private），不应该被直接引用

默认情况下，Python解释器会搜索当前目录、所有已安装的内置模块和第三方模块, 搜索路径存放在sys.path 


class
    __init__方法的第一个参数永远是self，表示创建的实例本身
    实例的变量名如果以__开头，就变成了一个私有变量（private），只有内部可以访问，外部不能访问


try...except...finally...的错误处理机制

file    
    >>> f = open('/Users/michael/test.txt', 'r')
    read()方法可以一次读取文件的全部内容
    close()方法关闭文件。
    readlines()  // for line in f.readlines():

StringIO     在内存中读写st StringIO操作的只能是str，
BytesIO     如果要操作二进制数据，就需要使用BytesIO
    

